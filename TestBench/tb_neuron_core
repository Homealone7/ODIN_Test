module tb_neuron_core;
    reg  RSTN_syncn = 1'b0;
    reg  CLK = 1'b0;

    // Inputs for synaptic_core
    reg  SPI_GATE_ACTIVITY_sync;
    reg [255:0] SPI_SYN_SIGN;
    reg  SPI_UPDATE_UNMAPPED_SYN;
    reg [7:0] CTRL_PRE_EN;
    reg  CTRL_BIST_REF;
    reg  CTRL_SYNARRAY_WE;
    reg [12:0] CTRL_SYNARRAY_ADDR;
    reg  CTRL_SYNARRAY_CS;
    reg [15:0] CTRL_PROG_DATA;
    reg [15:0] CTRL_SPI_ADDR;

    // Inputs for neuron_core
    reg  SPI_PROPAGATE_UNMAPPED_SYN;
    reg  CTRL_NEUR_EVENT;
    reg  CTRL_NEUR_TREF;
    reg [4:0] CTRL_NEUR_VIRTS;
    reg  CTRL_NEURMEM_CS;
    reg  CTRL_NEURMEM_WE;
    reg [7:0] CTRL_NEURMEM_ADDR;
    reg  CTRL_NEUR_BURST_END;

    // Outputs from synaptic_core to be connected to neuron_core
    wire [31:0] SYNARRAY_RDATA;
    wire SYN_SIGN;

    // Outputs from neuron_core
    wire [127:0] NEUR_STATE;
    wire [6:0] NEUR_EVENT_OUT;
    wire [255:0] NEUR_V_UP;
    wire [255:0] NEUR_V_DOWN;
    wire [14:0] NEUR_STATE_MONITOR;

    synaptic_core sc (
        .RSTN_syncn(RSTN_syncn),
        .CLK(CLK),
        .SPI_GATE_ACTIVITY_sync(SPI_GATE_ACTIVITY_sync),
        .SPI_SYN_SIGN(SPI_SYN_SIGN),
        .SPI_UPDATE_UNMAPPED_SYN(SPI_UPDATE_UNMAPPED_SYN),
        .CTRL_PRE_EN(CTRL_PRE_EN),
        .CTRL_BIST_REF(CTRL_BIST_REF),
        .CTRL_SYNARRAY_WE(CTRL_SYNARRAY_WE),
        .CTRL_SYNARRAY_ADDR(CTRL_SYNARRAY_ADDR),
        .CTRL_SYNARRAY_CS(CTRL_SYNARRAY_CS),
        .CTRL_PROG_DATA(CTRL_PROG_DATA),
        .CTRL_SPI_ADDR(CTRL_SPI_ADDR),
        .NEUR_V_UP(NEUR_V_UP),
        .NEUR_V_DOWN(NEUR_V_DOWN),
        .SYNARRAY_RDATA(SYNARRAY_RDATA),
        .SYN_SIGN(SYN_SIGN)
    );

    neuron_core nc (
        .RSTN_syncn(RSTN_syncn),
        .CLK(CLK),
        .SPI_GATE_ACTIVITY_sync(SPI_GATE_ACTIVITY_sync),
        .SPI_PROPAGATE_UNMAPPED_SYN(SPI_PROPAGATE_UNMAPPED_SYN),
        .SYNARRAY_RDATA(SYNARRAY_RDATA),
        .SYN_SIGN(SYN_SIGN),
        .CTRL_NEUR_EVENT(CTRL_NEUR_EVENT),
        .CTRL_NEUR_TREF(CTRL_NEUR_TREF),
        .CTRL_NEUR_VIRTS(CTRL_NEUR_VIRTS),
        .CTRL_NEURMEM_CS(CTRL_NEURMEM_CS),
        .CTRL_NEURMEM_WE(CTRL_NEURMEM_WE),
        .CTRL_NEURMEM_ADDR(CTRL_NEURMEM_ADDR),
        .CTRL_PROG_DATA(CTRL_PROG_DATA),
        .CTRL_SPI_ADDR(CTRL_SPI_ADDR),
        .CTRL_NEUR_BURST_END(CTRL_NEUR_BURST_END),
        .NEUR_STATE(NEUR_STATE),
        .NEUR_EVENT_OUT(NEUR_EVENT_OUT),
        .NEUR_V_UP(NEUR_V_UP),
        .NEUR_V_DOWN(NEUR_V_DOWN),
        .NEUR_STATE_MONITOR(NEUR_STATE_MONITOR)
    );

    initial begin
    // Initialization
    RSTN_syncn = 1'b0;
    #10 RSTN_syncn = 1'b1;
    
    // Test Inputs for synaptic_core
    SPI_GATE_ACTIVITY_sync = 1'b1;          // Allow gate activity
    SPI_SYN_SIGN = 256'b10101010101010101010101010101010; // Some random synaptic sign data
    SPI_UPDATE_UNMAPPED_SYN = 1'b1;         // Update the unmapped synapse
    CTRL_PRE_EN = 8'b00000001;              // Enable specific pre-synaptic neurons
    CTRL_BIST_REF = 1'b0;                   // No BIST reference
    CTRL_SYNARRAY_WE = 1'b1;                // Allow writing to synaptic array
    CTRL_SYNARRAY_ADDR = 13'b0000000000001; // Address for synaptic array
    CTRL_SYNARRAY_CS = 1'b1;                // Chip select for synaptic array
    CTRL_PROG_DATA = 16'b1100110011001100;  // Some data to program
    CTRL_SPI_ADDR = 16'b0000000000000001;   // SPI address
    
    #10; // Wait for 10 time units
    
    // Test Inputs for neuron_core based on synaptic outputs
    SPI_PROPAGATE_UNMAPPED_SYN = 1'b1;      // Propagate unmapped synapse
    CTRL_NEUR_EVENT = 1'b1;                 // Trigger neuron event
    CTRL_NEUR_TREF = 1'b0;                  // No time ref
    CTRL_NEUR_VIRTS = 5'b00001;             // Virtual source for neurons
    CTRL_NEURMEM_CS = 1'b1;                 // Chip select for neuron memory
    CTRL_NEURMEM_WE = 1'b1;                 // Allow writing to neuron memory
    CTRL_NEURMEM_ADDR = 8'b00000001;        // Address for neuron memory
    CTRL_NEUR_BURST_END = 1'b0;             // No burst end for neuron
    
    #20; // Wait for 20 time units
    
    // Check outputs
    // ... 
end

    always #5 CLK = ~CLK; // Clock generation

endmodule